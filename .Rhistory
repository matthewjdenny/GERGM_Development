install.packages("scrapeR",dependencies = T)
library(scrapeR)
get_google_scholar_results <- function(string, return_source = FALSE){
# for testing
# string <- "Bruce Desmarais"
# print out the input name
cat(string, "\n")
# make the input name all lowercase
string <- tolower(string)
# split the string on spaces
str <- str_split(string," ")[[1]]
# combine the resulting parts of the string with + signs so "Matt Denny" will end up as "matt+denny" which is what Google Scholar wants as input
str <- paste0(str,collapse = "+")
# add the name (which is now in the correct format) to the search querry and we have our web address.
str <- paste("https://scholar.google.com/scholar?hl=en&q=",str,sep = "")
# downloads the web page source code
page <- getURL(str, .opts = list(ssl.verifypeer = FALSE))
# search for the 'Scholar</a><div id="gs_ab_md">' string which occurs uniquely right before google Scholar tells you how many results your querry returned
num_results <- str_split(page,'Scholar</a><div id=\\"gs_ab_md\\">')[[1]][2]
# split the resulting string on the fist time you see a "(" as this will signify the end of the text string telling you how many results were returned.
num_results <- str_split(num_results,'\\(')[[1]][1]
# Print out the number of results returned by Google Scholar
cat("Querry returned", tolower(num_results), "\n")
# Look to see if the "User profiles" string is present -- grepl will return true if the specified text ("User profiles") is contained in the web page source.
if(grepl("User profiles",page)){
# split the web page source (which is all one string) on the "Cited by " string and then take the second chunk of the resulting vector of substrings (so we can get at the number right after the first mention of "Cited by ")
num_cites <- str_split(page,"Cited by ")[[1]][2]
# now we want the number before the < symbol in the resulting string  (which will be the number of cites)
num_cites <- str_split(num_cites,"<")[[1]][1]
# now let the user know how many we found
cat("Number of Cites:",num_cites,"\n")
}else{
# If we could not find the "User profiles" string, then the person probably does not have a profile on Google Scholar and we should let the user know this is the case
cat("This user may not have a Google Scholar profile \n")
}
# If we specified the option at the top that we wanted to return the HTML source, then return it, otherwise don't.
if(return_source){
return(page)
}
}
get_google_scholar_results("Laurel Smith-Doerr")
library(stringr)
get_google_scholar_results("Laurel Smith-Doerr")
get_google_scholar_results("Brendan O'Connor")
load("~/Desktop/GERGM_Development/Financial_model_1.RData")
True.stats <- MH.fit@stats[1,]
temp.stats <- MH.sims$Statistics
temp2.stats <- MPLE.sims$Statistics
#Re weighting the recip and ttriads to correct level
temp.stats$recip = temp.stats$recip ^ (1/0.1)
temp.stats$ttriads = temp.stats$ttriads ^ (1/0.1)
temp2.stats$recip = temp2.stats$recip ^ (1/0.1)
temp2.stats$ttriads = temp2.stats$ttriads ^ (1/0.1)
## plot goodness of fit
indx = order(True.stats)
par(oma=c(1,1,1,1))
par(mar=c(4,4.5,2,1))
spacing = seq(1,401, by = 15)
par(mfrow = c(1,1))
boxplot(log(temp.stats)[indx], ylab = "Log value", cex.axis = 1.5, cex.lab = 1.5, main = "Metropolis-Hastings", cex.main = 1.5)
lines(log(True.stats)[indx], type = "b", lwd = 3, pch = 5, lty = 8, col = "blue")
legend("bottomright", "Observed", lwd = 3, pch = 5, lty = 8, col = "blue", cex = 1.25)
par(mfrow = c(1,1))
boxplot(log(temp2.stats)[indx], ylab = "Log value", cex.axis = 1.5, cex.lab = 1.5, main = "MPLE", cex.main = 1.5)
lines(log(True.stats)[indx], type = "b", lwd = 3, pch = 5, lty = 8, col = "blue")
#legend("bottomright", "Observed", lwd = 3, pch = 5, lty = 8, col = "blue", cex = 1.25)
## plot MCMC trace plot on edge density
plot(unique(temp.stats[,6]), type = "l")
summary(MH.fit)
setwd("~/Desktop/GERGM_Development")
library(RcppArmadillo)
Rcpp::sourceCpp('Scripts/MH_Sampler_Normal_Together.cpp')
source('Scripts/GERGM.R', echo=F)
summary(MH.fit)
MH.fit
temp.stats <- MH.sims$Statistics
temp.stats
temp.stats <- MH.sims$Thetas
temp.stats
temp <- MH.fit$Thetas
str(MH.fit)
temp <- MH.fit@theta.coef
temp
temp = temp ^ (1/0.1)
temp
temp <- MH.fit@theta.coef
temp = temp ^ (0.1)
temp
temp <- MH.fit@theta.coef
z.stats <- temp[1,]/temp[2,]
z.stats
2*pnorm(-abs(z.stats))
2*pnorm(-abs(z.stats[1]))
MH.fit
temp <- MH.fit@theta.coef
z.stats <- temp[1,]/temp[2,]
2*pnorm(-abs(z.stats[1]))
View(z.stats)
z.stats <- as.numeric(temp[1,]/temp[2,])
2*pnorm(-abs(z.stats[1]))
2*pnorm(-abs(z.stats[2]))
